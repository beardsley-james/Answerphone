Overview 9/14/19

index.css
  div: set for margin 1%, height 200%, whatever that means, I think I can remove this altogether
  #liveCalls: this is one of the call queue objects, it has a 1 pixel border and it floats left. this seems fine.
  #numLive: this is the number at the top of the screen, it is the same color as #liveCalls. seems fine.
  #holdingCalls & #numHolding: same deal, maybe tweak what red
  #numCompleted & #numLost: these are just the little boxes at the top they're fine, but I should apply a class to the values and give them some common attributes and maybe attach them all altogether
  .callStatBox: I'm not sure what this is. Let's fine out. Oh this is the common class for the boxes, I guess I already did this. It just applies some padding. Can probably do more with this.
  #opPool: this is the operator pool, I don't know if it needs to have the width changed or the call queue objects do, probably them
  .call: this is the box that the calls spawn into. it is styled to look like the spectrum telescan app stuff but I don't think it needs to, I could probably come up with more of my own stuff. simple margin/padding values seem fine.
  .op: I think I need to set some kind of height value for this or something, every time someone gets a call that has any kind of vertical heft it shunts other ops over in weird ways that I don't like.
  .active: maybe a different color than "green".
    // need to add some other things in here for different kinds of calls like finishing a call or whatever instead of just having active/inactive
  .inactive: empty value, can probably remove
  h1: just centers the titles i can probably do more here, should also put in some h1/h2s instead of just using h1 for everything but that's html stuff
  #speedcontrol.botton: this doesn't even have a value it just specifies width and doesn't do anything
  .panel: clears floats so that it doesn't look freaky when more than one panel is visible
  .clientId: set to float right, this doesn't do anything, can just take it out

core.js
  variable section at the top: can probably take the variables in queue.js and move them up here, honestly most of the stuff in queue.js should be split between this file and test.js so I have test conditions set in an isolated place that's easy to mess with and comment out when I want a clean slate. msPerMin is a variable that determines how long a game minute takes in real time, it is used for the timer function. callFreq is a variable that gets altered during the timer function to determine which accounts can produce calls. minutesInDay is how many minutes happen in a day - it's set for 1440 right now, the same as the number of minutes in a real day, but I could change that for gameplay reasons. currentMinute is the timer and it gets incremented by the timer() function, it is also used to check whether or not to alter the call frequency against the object that contains the stats for calls for that day of the week. the day veriable is only monday now but I'm going to put in other days of the week and then it'll change depending on which day of the week it is. I don't know if I want to use an integer 0-6 for this or a string - if it's a string I can use an object to keep track of days of the week but I don't know if that's necessarily a useful thing to do. money is the incrementer that keeps track of how much money you have, it's an integer representing the number of cents and then there's a function that turns it into dollars for display. daysElapsed is only used right now to determine whether or not to reset the day end chart display but it may be used for more things later.
  opStartup(ops) and clientStartup(clients): this is going to go into the load game function when that gets implemented, for now it can probably go in test.js to start everything up
  phoneRinger(client): this checks a client object against a random number between 0-100 and if the frequency is lower than the random number it makes a new call and pushes it into the live call queue. it also puts it into the DOM. the DOM element and the object in the live call array are connected by a call id number that is in another file but should probably be part of whatever file that is declaring the rest of the variable. maybe I should declare variables in a separate file that loads first I don't know.
  timer(): this is like the core function for the game. right now it sets a timeout for the length of whatever the msPerMin variable is set for. it checks whether or not the dailyFreq chart for the day has a value for the currentMinute and if so it sets the call frequency for that value. it checks each client to see if they should have a chance of generating a call with the phoneRinger function above. each of the operators runs through the callChecker function to see what they should be doing with their calls. the callQueue advances, each call gets increments for how long it's ringing or on hold, then the boxes with the calls in them get updated with the new stats, the current minute display gets updated, any buttons that can't be purchased with the current amount of money get turned off or turned on if they are affordable now, it runs through each of the advertisements to see if they are giving a new lead or if they should be reset to the off position, the current minute increments, and if the the current minute is equal to the number of minutes in a day it runs the end of day process and gives a report, otherwise it sets a timer for the current msPerMin and runs again ad infinitum. downsides right now are that if you click on the super slow motion button you have to wait until it times out before it starts running at the new speed when you're done being in slow mo. there also isn't really a way to pause it right now which needs to happen. the phoneringer function and callChecker function could run through the operators/clients themselves without using a foreach in here, don't know if that would speed anything up but it would look a little prettier, i mean all the if message stuff could probably get wrapped up in a function if i wanted but i don't know if that would help anything for real.
  callChecker(op): this function gets an operator. it checks to see if there is anything in the call array in the operator object. if there is, it checks whether or not the operator's call was picked up live and the operator hasn't been on the call for very long and if the live calls queue has a value. if all of those things are true it puts the operators call on hold and grabs a call from the live call queue. this uses the callGrabber function which needs to be updated. if all of those things aren't true, it checks wheter or not the operator is currently finishing taking a message. if so it decrements the time to complete. if not, it checks to see whether or not the operator has finished with the message ticket they're on. if the operator is finished, it deletes the callToComplete property from the call object, runs through the client list to see which one should be billed for the call and adds it to their total calltime (should it just add the money? i dunno). it increases the money pool by the amount that the client should be billed for, updates the money display in the DOM, move the call to the completed calls section, and increases the op's value for the number of calls that they finished for the day. there should be more stats that get tallied up here and it should probably be a function that gets passed the operator object. if the operator is just on a call but is not finished with it and isn't going to put it on hold, the calltime is incremented and it check to see if the operator is finished with the call. right now it's passing the operator and the call but the call is just a property of the operator so i should probably just pass the operator object and take the call out of it in the checkIfCallCompleted function. if the operator is not in a call, they will pick up a call from the live queue if available or else from the holding queue or else their idle time will increment. I need to make it so they can only pick up calls of their levels and I need to change the way the callGrabber function works to do so. this is also the function that's going to end up processing any kind of dispatch attempts that are going on so it needs to be gone over pretty significantly. whatever else happens, at the end of the function it runs the opUpdater(op) function function to update the DOM. this is fine but that function needs to updated for more variable operator states. this is also going to need to be updated to use op stats to determine what happens with the call.
  callGrabber(target, destination): this is the function that moves calls between different arrays but right now it only takes a target array and a destination array and it needs to be more intense. it should probably be callGrabber(target, index) so it grabs a specific thing, updates the DOM, and then returns the object that gets sliced so that it can be pushed or whatever in a function in whatever's using the callgrabber. right now it takes the first element of the target array and turns it into the "call". it pushes the call into the destination, that's it, so that's what needs to more involved. because right now it's just working off the top. the latter section is more interesting though; if the operator is grabbing a call from the live or holding queues, it removes the DOM element for the call since the operator is handling it now. if the destination for the call is the holding queue, because the call has been put on hold, it pushes the call into the holding queue at the bottom of the list. the queue DOM objects display in the reverse order of the javascript objects which is interesting; last in first out sort of. if the callGrabber is losing a call, though, it takes the call out altogether. the putting a call on hold and losing a call things probably need their own functions but the thing that takes the call out of the queue is fine as is. i need to go through and find all instances using the callgrabber and change it though. chances are putting a destination.push(callGrabber(target, index)) will cover most of them but i might need to program putOnHold(callGrabber(target, index)) and lostCall(callGrabber(target, index)) to make it work.
  checkIfCallCompleted(op, call): i can just change this to (op) and pull the call inside of the function. it adds the operator level to a random number 1-5 and checks it against the difficulty of the client (could also be randomized for funsies) and then if the skill check is higher than difficulty it sets the timeToComplete for the call to a number between 0-3 to determine how long it will take the operator to finish the call.
  callQueueAdvance(): this function gets called every time the timer fires. it goes through the holding and live calls and increments each of them for timeOnHold or TimeRinging and if it's more than 5 or 3 respectively it pulls the call and puts it into callQueue.lost. this used to use the callGrabber function but it would just take the top one off and made some weird stuff happen so this is where the code is that i'll probably use for the new callGrabber function. if the timer doesn't go off it uses callRefresh to update the stats in the call.
  extractCallNumber(elementId): this is a little utility function that takes a string and checks it against a regEx to turn a "call###" into ### for manipulating in the model.
  manualAnswer(event): this is the function that gets called when you click on a call so that you can answer calls yourself and make some money without using weak ops to do your work for you. this is where extractCallNumber works. it sets a target variable for the thing that you clicked on, take the callerId out of the target's id, sets the category to the id of the parentnode ("holding" or "live"), and then makes a blank object to turn into the call. it checks the callQueue model object and looks for a call with the id # of the call you clicked on. when it finds it, it sets the value of callObj to the value of that call and uses splice to remove the call from the parent object. i don't know why callObj doesn't = splice(whatever), did I try this once and it didn't work? i should probably try it again, don't need to use two functions to take care of something i should be able to do in one. if the call you clicked on was in the holding queue, it increments the time, adds the call time to whatever client the call came from, adds the money to the bank for it, updates the money display, moves the call to the completed section, and takes the call out of the DOM. this is almost exactly what happens when an operator finishes a call and i should probably make it a separate function. if the call is from the live queue, it move it over to the holding queue and updates the DOM, a lot simpler. after this is over it refreshes stat boxes for the call, i'm not sure why?
  endOfDay(): this is the function that generates reports to display in the end of day panel. it makes a report object with the right properties and then sets the values of those properties using the stats from the day. right now it tallies the number of completed calls, the number of lost calls, it generates reports for each of the ops with their names, the number of calls they finished, and the amount of time they were idle and then it does the same for clients but it also displays how much money it was worth for each of them and adds the value to the total earned for the day. it goes through each of the completed calls too and adds them to counters for time on hold, time ringing, and total call time and then it returns the report object. i can add a lot of things into this function.
  clearDay(): this sets all the variables tallied in endOfDay to 0 for the start of new day but this function should just get combined with endOfDay honestly. it really just increments through some stuff and blanks it.
  disableUnaffordableButtons(): this gets everything that has the expenditure class on the page, uses a regular expression to figure out how many dollars it costs to buy whatever (also a class dol###), and then it goes through the list of the button and disables them if they cost more than the current money() value. this function is great and doesn't need anything.
  startCampaign(campaignType): this is the onclick function for the advertising campaign buttons. it makes a new advertising campaign object and then pushes into both an active campaigns array and the DOM, takes the money out of the bank, and turns off the button that you use to buy the campaign so you can only buy one of each campaign. i might want to make a more universal version of this one so all kinds of expenditure buttons can be used but i don't like have to.
  checkAdvertisements(): this through each of the items in the active campaigns array. if the campaign is over it runs the updateAdvertisementCard function in the render file, which removes the campaign from the active campaign list, and then it take the object out of the active campaigns array and turns the button back on so it can be started again. if the campaign isn't over, it runs a math check to see if the campaign triggers. if it does it either pushes a new operator or a new client into the applicable arrays and then puts them into the list of available items in the DOM. this is working fine. then it updates the campaign list and decrements it.
  hireOp(opInitials): first this finds the index of the operator it's looking for and then it splices it into the active ops section. it adds the operator to both the callqueue screen and the human resources screen and then it takes the listing out of the applicant list on the human resources screen. working as intended.
  declineOp(opInitials): does the same thing as hireOp except that it doesn't put them in the callqueue or hired ops section, just takes them off the list and out of the array.
  acceptContract(clientId): literally the same thing as hireOp but for clients
  declineContract(clientId): same thing as decline op for clients
  and then at the end it starts the timer and shows the callQueue panel but I don't think it really needs to do this here, there should probably be a more dedicated startup section that takes care of this, not sure where to put that though. it'll probably be the same section that looks for like a save file in the browser space or creates save files, like initiate.js or something which should probably be the last file called. i don't know yet if i want to mix this all into one big file but i like it as a lot of small ones just for working on it at this point.

databases.js
  advertisingCampaigns{}: this is where I'm keeping different advertising campaigns. these are placeholders right now but i need to figure out a scheme for how they're going to work pretty soon. this is also going to be a big place where your different upgrades are going to come into play because i plan on having advertisements gated behind the upgrade tree, probably with different paths for hr campaigns versus sales campaigns. there's also the possibility of having other types of campaigns but i can't imagine what off the top of my head. i want the advertising list to be autopopulated here. i need an unlocked property on each of these too. i could also make like a constructor and have them get pushed into an aray of available campaigns? but i don't really need to do that i don't think, i don't plan on having that many of them. it would be graceful though.
  messages{}: this has all the possible messages for the different kinds of companies that can have accounts with the answering service. i'm thinking about combining this with some of the other company type specific objects into a big like types object that has different objects nested into it with messages and stuff as properties but then it might make everything more unwieldy. maybe this is better? at least everything would be all consolidated into one place, though. if i want to add another type of company i have to add it in several places to make it work, including the really pointless "types of companies" list i put together. i can probably use the keys from one of the other objects instead of having that if i decide not to do it the new way though.
  there aren't nearly enough messages in here, they kind of show up over and over again. ideally i'd have like hundreds of possible slightly different messages for each kind of company. i wonder if i could crowdsource this.
  businessNames{}: this is the same list as the messages section which is why i think i could combine them. this is an array of objects that get used to put together business names but it's kind of a pain in the butt to edit. I don't know if I need to. the thing I was thinking about was maybe making nameType an array so that it could randomly generate from a number of different types of possible business names which should be pretty easy to do. typeOf(category.nameType) == "Array" should do it, or something like that, and if so it randomly picks from the options. I also need a lot of differnt templates in here and i should keep in mind that very small differences could add up to very big differences in results since there's so many of these guys floating around.
  names{}: this is a list of first and last names. i decided to go culture neutral on this because if there's anything you learn working at a real answering service it's that name patterns don't mean that much and may not actually exist. this is a hungry list, though. there are so many calls coming in that repeats are bound to happen unless there's an absolutely massive number of options to draw from. i'm considering pulling in names from another source, someone somewhere must have made a JSON list of first and last names, otherwise i'll keeping adding them 10/20 at a time and hopefully i can get into the hundreds someday. only problem is repeats. i may move this object to its own file. i probably need more last names than first names though.
  businessTypes[]: this makes me mad and i need to figure out how to get rid of it.
  callFreqRanges{}: this determines the max/min of the callFreq stat that's generated for new businesses being added to the client list. i don't know maybe i need to tweak this i'm not sure it's doing anything. if i don't tweak it, it'll become a property in the new businessTypes object which is going to include businessNames and message.
  dailyFreq{}: this is going to be the generic unaltered frequency changes that occur throughout the work day. the keys are time (in minutes) that the frequency changes. i need to add all the rest of the days and also remix some of these numbers because it picks up around 6 and that's an hour too late so i got that wrong somewhere. i can figure this out at work. i don't know if i want to keep it as an object with days of the week as keys or i could change it to an array with seven options. i want a kind of recreation of the callfrequency changes i deal with at the real answering service which means sometimes accounts have crazy numbers of calls that come in at weird times. i'm also not totally sure that this is the proper way to handle call frequency. originally the concept was to have a crazy big array for each of the clients with like the chances for every minute that they would pop a call but that is actually crazy. this might work better and it would be easy to alter for holidays or a weather event. a holiday might decrease the frequency level for all accounts where a weather or health event or whatever would apply to only specific categories of clients. i think the check would have to happen in callChecker() though. fixing the daily frequency chart, making different days have different levels of call volume, and implementing dates/holidays/weather events should be a pretty big priority for development i think but they're already on my to-do list.

generators.js
  generateFullName(), generateFirstName(), generateLastName(): very simple functions that randomly pick an item from one of the name lists. fullname just calls the other two. i really just like how they look better than calling the randomize function every time.
  clientId: this is a variable that increments when clients are generated. i should probably have somewhere better to initiate it but i don't right now. i should move this.
  clientGenerator(difficulty): difficulty doesn't totally do anything right now and i probably want something different to bring in here. one option would be to have the function get passed an object, put together elsewhere, that says what types of business are approriate,  around what difficulty it should be, and some other options too with default options if they aren't specified. right now it just blasts through a couple random generation options and throws something together but it could get a lot more focused if i wanted it to be. what would i benefit? i could get more granularity with the progression of the game, i could have different objects to represent the different options for different towns you can be in. this actually seems indispensable and is going onto my todo list posthaste.
  returnNumberInRange(min, max) is a bog standard randomizer and should be in a utility file by itself since i'll never want to do anything with it. should i do that, maybe? just have a file where i put standalone things that i know are fine and i don't want to mess with them.
  detemineOpLevel(difficulty): just gives you an appropriate operator level for a given difficulty, could be wrapped into clientGenerator since i don't use it anywhere else.
  callCheck(frequency): this checks to see if an account generates a call, this should be in core.js
  callNumber: another variable that belongs elsewhere
  callGen(company): here we go, this one takes an object and uses it, that's more what i was going for. it doesn't use it that much, though, it just pulls some properties in. there's probably a lot more i could do to really personalize the calls that are generated for different accounts. it would involve grabbing some different sets of messages and applying them, like cold weather messages and stuff, and then there would be a constructor function to run at the beginning of the day to apply different variables to the kinds of messages that showed up. like in the winter, you might get a blizzard and then you'd activate the winter subcategory of messages which include specific things for different types of accounts, like there would be doctors treating frostbite and stuff. this is very different than what i was discussing above, where i said that you could wrap the messages categories into the type settings, this would have keyword based messages i think and then you would make big call generator objects at the beginning of the day. i get what i'm going for her, i think it would be interesting but complicated to work out. something to think about tomrrow at work probably.
  randomPercent() generic random number generating function
  minToMilTime(minutes) and minToStandardTime(minutes) take the number of minutes (as tracked by the minutes variable) and turn it into a string for different times so the options panel should have military/standrad time as options for display
  opGenerator() is a placeholder function, basically. it barely generates anything and all the operators are identical except their names. this needs to take a setting object, too, since your answering service is going to attract different kinds of ops. this could be a pretty fun part actually. this is going to need to pull from a database that has a bunch of backgrounds/experiences with stat values to add up to the profile stats or whatever, probably in the form of {name: "Homemaker", focus: 2, personability: 6} or something and that's gonna pull in the bulk of the customization for these guys but maybe I want to put different pools together and pull them together to make communities or whatever, like so you get higher stat people when you're ready to pay people more.
  initialsGenerator(): this puts 3 letters together to make some initials. theoretically i could give the operators real names but just using initials makes it feel like answerphone to me. everyone at my job calls each other by their initials instead of their names because that's what shows up on the board. it's a little dehumanizing which is exaclty the flavor i'm going for with this project. there's a little if/else at the bottom that checks to see if someone already has those initials. does it work? so far. i haven't actually tested it but i think it works.
  initialsChecker(initials): this checks ops and possibleOps to see if anyone already has some initials. i had it set up a different way but this is what i settled on, i don't know why.
  generateBusinesName(type): this is very different than generateInitials because it has to give a full name and some other stuff. right now it just goes through the different possibilities for the business type, picks one at random, figures out what kind of name it's supposed to take and slots it in, but i think i want to open this up a bit and let the name options get passed as an array and pick from different options randomly so some business names of the type could have full names and others could have first names and yet others could be selected from a list of exclamatory adjectives like "GREAT HVAC" or something. i like that idea and i should implement it.
  businessNameChecker(name) is the same as initials like literally the same except it checks different lists that's it.
  campaignId should go somewhere else
  campaignGenerator(campaignType): this generates a new campaign object based on the campaignTypes options in database.js, I don't think this actually needs much to do.

index.js
  I've just been using this as a scratch pad it isn't actually doing anything.

models.js
  This is an empty file. what do I even want to do with this?

queue.js
  originally this was going to be the file that handled queue behavior but somehow i ended up doing a lot more with core.js than what i'm doing here and this has become sort of a test state initializer, which i want to switch over to being handled by a save file system that eventually get tied to local memory to allow save games.
  the whole first twelve lines are just establishing empty sets to be filled elsewhere. this might actually be where the save file is, isn't it, these variables are pretty much the game state except for some counters. maybe i'll start working on the save file system in here.
  a couple for statements generate random clients/operators and put them into clients[] and ops[] wherer the game can work with them. basically just a test state. not a controlled one though, since randomization is one of the big features i'm testing. do i want an equal number of ops and clients to be near optimal? symmetry is nice but i guess you're going to need more ops than clients at some point since it seems like one busy client is enough to result in some missed calls. i guess that's going to be a call for the player, since losing calls is going to hurt your relationship with the clients but overstaffing loses you money and it's all about the profit. maybe i could make some kind of political point by having something other than profit drive the game though. there are going to be shifts i think, since not everyone is going to work at the same time, so you'll need more operators than clients probably. guess we'll see. there's still a lot left to do on this.

render.js
  callRender(call): this makes a div element and then fills it up to produce a "call" object as contained in the callQueue in index.html. it takes a call object (produced in generator) and does the name, message, and client on it and adds a stat line with an id that can be edited easily by a later function. this is a good one because i can just add other stuff to this or subtract it as i want. i decided to do straight js for this project instead of using any kinds of libraries - jquery would make this section a lot shorter but i kind of like being able to manipulate the DOM with straight js without having to use a framework for it. i haven't done any of this stuff for a few years so i don't know if people are as into jquery now as they used to be either.
  callRefresh(call): this grabs the element containing the call based on the id and updates the stats with the latest stats.
  callStatBoxRefresh(): this updates the stat box on the top of the screen.
  lineBreak(): is there a better way of adding a line break to a DOM object? i don't know if there is i haven't really tried very hard to look. this just creates a <br> element and returns it. i really just have this here so i don't have to += "<br>" all over the place. is .appendChild(lineBreak()) that much better? i don't know. it looks better. i guess i want to not have that much actual html in my javascript with strings and stuff.
  removeCall(call): this grabs a call based on the id and deletes it from its parent node. i think i could switch in a generic removeElement function though and just do the legwork of figuring out which id to pull in the actual function call which is probably a better idea.
  
